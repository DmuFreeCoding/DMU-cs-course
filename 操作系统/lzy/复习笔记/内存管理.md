## 内存管理
### 存储器管理方式
#### 连续内存分配
- **单一连续区分配**
- **固定分区**：包含请求表和内存分配表，有**内部碎片**，易于实现
- **可变分区**：运行过程中根据进程大小动态建立，有**请求表、已分配分区表、空闲区表三个数据结构**，
1. 可变分区有计算题，包括三种分区算法**最先适应：尽可能找低地址、最佳适应：满足空间的最小空闲区、最坏适应：找最大的可用区分配**
2. 可变分区的回收（用完之后）：合并下分区需要改首址，不邻接需要建立新表项
3. 可变分区的碎片问题：外碎片问题：解决方式为内存紧缩或者离散分配方式
#### 离散分配方式（考计算）
##### 分段：
- **定义**：程序员把程序按照含义分成若干段，**每段是连续的**,创建进程时，建立进程段表，段表包括各个段的起始位置和长度
- **段地址映射的方法**：根据段号找段表，映射到段的基物理地址，再加上偏移地址
##### 分页：
- **定义**：将内存划分为若干个长度相等的页，由**硬件自动完成**
- **地址映射方法**：通过页号访问页表找到页框号，页框号对应的一个页面的初始地址+偏移地址=物理地址，根据进程所需空间的大小分配页框的个数
- **地址计算方法**：给出一个虚地址，除以页大小取整=>页号，剩下的是偏移量，通过页号找页框号，页框号*页大小+偏移量=物理地址
- **数据结构**：
	- 页表：每个进程一个
	- 请求表：整个系统一个，包括进程的页表初始地址、页表长度（**可以用于找到每个进程的页表**）
	- 位示图/空闲页面链表：每个系统一个，代表整个内存空间的内容，可以得知内存空间的空闲程度
- **快表TLB**:存放着当前页的部分页表项，遵循局部性原理，支持并行查找
	- **有效访问时间的计算**：命中率x(TLB+MA)+非命中率x(TLB+2MA）
- **多级页表**：大地址空间用
- **哈希页表**：每个表目包含一个链表，处理冲突，每个元素包括逻辑页号、物理页号和指向下一元素的指针，每次查找时，通过比对逻辑页号对应的物理页号
- **倒置页表**：整个系统一个倒置页表，表的内容有进程的pid和页号

#### 内存管理技术的优缺点
- **静态页式管理**：优点：没有外碎片，缺点：必须一次性全部装入内存，有内碎片
###### 段页式管理
**定义**：将用户程序划分为段，然后查找段表，段表内给的是页表的长度和起始地址，然后查找页表获取各个页面，**段表是一个程序一个，页表是一个段一个，获取物理地址需要三次访存**
### 地址绑定的方法
*什么是重定位？*
*将逻辑地址映射到物理地址的操作*
- **动态重定位**：利用硬件实现，需要BR和VR
- **静态重定位**：编译时生成重定位代码，修改代码里的地址为物理地址
### 内存保护方法
- **硬件法**:采用寄存器来保护，**上界寄存器<=物理地址<=下界寄存器**，**0<=逻辑地址<限长寄存器**
- **软件法**：采用保护键实现，对应的地址必须送对应的保护键和读写指令才能成功操作
### 外存调入内存的方法
- **覆盖技术**：**没啥说的，会算就行**
- **交换技术**：从外存调入时，交换整个进程的地址空间




