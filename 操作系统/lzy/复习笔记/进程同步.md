### 进程同步和实现进程同步的各种方法
#### 临界区问题
**临界资源**：一次仅允许一个进程访问的资源
**临界区**：访问临界资源的代码
**临界区原则**：互斥、有空让进、有限等待
#### Peterson方案
*对于每一个进程而言，应该遵循以下原则：*
*自己想进*
*让对方先进*
*是否能进（是否满足互斥变量）*
{

}
*修改自己互斥的变量，以便让对方有限等待*
#### 关中断
#### 硬件原子指令
一次执行，无法被打断，所以实现了同步
#### 优先级反转情况
*什么是优先级翻转？*=>优先级调度+忙等待
#### 信号量
##### 信号量的含义
**S=0**=>无资源可用
**S<0**=>等待队列中的进程个数
**S>0**=>有S个资源可用
除了初始化以外，只能通过PV操作访问，PV操作也是原语操作，包括**创建、撤销、阻塞、挂起、激活**等
**信号量的实现**：
`
Wait(S){
S->value--;
if(S->value<0){
添加这个进程到阻塞队列；
BLOCK()阻塞该进程；
}
}
`
`
Signal(S){
S->value++
if(S->value<=0){
撤销一个进程从阻塞队列；
唤醒一个进程；
}
}
`
**信号量的种类**：
1. 公有信号量：解决进程互斥问题，进程共享公有资源，初始化为1，每个进程均可以实现PV操作
2. 私用信号量：解决进程同步问题，进程共享对方的私有资源，初始化为0或者n，只允许拥有的进程施加P操作

#### 进程同步的几个问题
**生产者消费者问题**
- mutex:公用信号量，保证互斥
- avail:生产者的私有信号量，空缓冲区的个数，初始化为m
- full：消费者的私有信号量，满缓冲区的个数，初始化为0
**同步和互斥P操作在一起，同步在前，互斥在后，必须保证进入临界区最后一个操作是互斥操作**
**哲学家就餐问题**
- 保证两个相邻哲学家不会拿起同一根筷子
- 保证两个相邻哲学讲不会同时拿起同一根筷子，并且没有人饿死（有限等待）**采用奇数偶数的方法、或者只让四个哲学家入场的方法（初始化一个为4的同步信号量）**
**读者写者问题**
- 定义：多个进程可以同时读，但是只能有一个进程写
- 进程之间的互相制约关系：**写互斥信号量**：mutexW，用于两个作用：读者写者之间、写者之间互斥写。**当前在读的读者个数**：readCount，**读者之间的信号量，用于对readcount的加减变成原子操作**：mutexCount
#### 管程
互斥：管程内的数据只能通过其中的操作访问，并且一次只允许一个进程调用
同步：通过条件变量做PV操作来实现同步
操作系统本身不支持，是编译器的工作
#### 死锁
##### 定义：一组并发进程彼此互相等待对方所拥有的资源
##### 死锁发生的四个必要条件
1. **互斥条件**：资源为临界资源
2. **不可抢占条件**：进程占用的资源不会被强制拿走
3. **部分分配**：进程等待新资源时仍不放弃自己已有的资源
4. **环路等待条件**：存在一个互相等待的进程链

##### 死锁的处理方法
1. **死锁预防**：破坏死锁的必要条件，如资源变得可抢占，采用一次分配而不是部分分配等
2. **动态避免**：
- 发生的一瞬间避免=>**银行家算法**：*在每次分配资源之后，找到一个分配序列，使得每个进程的最大需求得到满足，则此次分配是安全的*；
- **资源分配图**：选择一个节点，消去它所有的分配边和请求边，别的进程也这样重复执行，如果所有进程都变为固定节点，则可以化简，否则是不可以化简的。
4. **检测并解除**：通过死锁的定理和资源分配图来检测死锁，通过**撤销进程、剥夺资源、进程回滚、无为而治**等来解除死锁

##### 例题
*z个资源，k个进程，每个进程需要m个资源，够不够分*
*满足k*(m-1)+1<=z，则够分*


